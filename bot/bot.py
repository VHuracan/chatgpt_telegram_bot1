import os
import logging
import asyncio
import traceback
import html
import json
import tempfile
import pydub
from pathlib import Path
from datetime import datetime, timedelta

import telegram
from telegram import (
    Update, 
    User, 
    InlineKeyboardButton, 
    InlineKeyboardMarkup, 
    BotCommand
)
from telegram.ext import (
    Application,
    ApplicationBuilder,
    CallbackContext,
    CommandHandler,
    MessageHandler,
    CallbackQueryHandler,
    AIORateLimiter,
    filters
)
from telegram.constants import ParseMode, ChatAction

import config
import database
import openai_utils

from ym import ymquickpay
from ym import checkpay

# setup
db = database.Database()
logger = logging.getLogger(__name__)
user_semaphores = {}


HELP_MESSAGE = """–°–ø–∏—Å–æ–∫ –∫–æ–º–∞–Ω–¥:
‚ö™ /retry ‚Äì –†–µ–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–µ–¥–∏–¥—É—â–∏–π –∑–∞–ø—Ä–æ—Å
‚ö™ /new ‚Äì –ù–∞—á–∞—Ç—å –Ω–æ–≤—ã–π –¥–∏–∞–ª–æ–≥
‚ö™ /mode ‚Äì –í—ã–±—Ä–∞—Ç—å —Ä–µ–∂–∏–º —Ä–∞–±–æ—Ç—ã –±–æ—Ç–∞
‚ö™ /settings ‚Äì –ü–æ–∫–∞–∑–∞—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
‚ö™ /balance ‚Äì –ü–æ–∫–∞–∑–∞—Ç—å –±–∞–ª–∞–Ω—Å
‚ö™ /help ‚Äì –ü–æ–º–æ—â—å
‚ö™ /premium - –ü–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ –ø—Ä–µ–º–∏—É–º
"""


def split_text_into_chunks(text, chunk_size):
    for i in range(0, len(text), chunk_size):
        yield text[i:i + chunk_size]


async def register_user_if_not_exists(update: Update, context: CallbackContext, user: User):
    if not db.check_if_user_exists(user.id):
        db.add_new_user(
            user.id,
            update.message.chat_id,
            username=user.username,
            first_name=user.first_name,
            last_name= user.last_name
        )
        db.start_new_dialog(user.id)

    if db.get_user_attribute(user.id, "current_dialog_id") is None:
        db.start_new_dialog(user.id)

    if user.id not in user_semaphores:
        user_semaphores[user.id] = asyncio.Semaphore(1)

    if db.get_user_attribute(user.id, "current_model") is None:
        db.set_user_attribute(user.id, "current_model", config.models["available_text_models"][0])

    # back compatibility for n_used_tokens field
    n_used_tokens = db.get_user_attribute(user.id, "n_used_tokens")
    if isinstance(n_used_tokens, int):  # old format
        new_n_used_tokens = {
            "gpt-3.5-turbo": {
                "n_input_tokens": 0,
                "n_output_tokens": n_used_tokens
            }
        }
        db.set_user_attribute(user.id, "n_used_tokens", new_n_used_tokens)

    # voice message transcription
    if db.get_user_attribute(user.id, "n_transcribed_seconds") is None:
        db.set_user_attribute(user.id, "n_transcribed_seconds", 0.0)


async def start_handle(update: Update, context: CallbackContext):
    await register_user_if_not_exists(update, context, update.message.from_user)
    user_id = update.message.from_user.id
    
    db.set_user_attribute(user_id, "last_interaction", datetime.now())
    db.start_new_dialog(user_id)
    
    reply_text = "–ü—Ä–∏–≤–µ—Ç –Ø <b>ChatGPT Telegram –±–æ—Ç</b> —è —Ä–∞–±–æ—Ç–∞—é —Å –ø–æ–º–æ—â—å—é GPT-3.5 Turbo OpenAI API ü§ñ, —Ç—ã –º–æ–∂–µ—à—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–æ–º–∞–Ω–¥—ã –∏ –æ–±—Ä–∞—â–∞—Ç—å—Å—è –∫–æ –º–Ω–µ –Ω–∞ –†—É—Å—Å–∫–æ–º –∏–ª–∏ –ê–Ω–≥–ª–∏–π—Å–∫–æ–º —è–∑—ã–∫–µ\n\n"
    reply_text += HELP_MESSAGE

    reply_text += "\n–ê—Å–µ–π—á–∞—Å... —Å–ø—Ä–æ—Å–∏ –º–µ–Ω—è –æ —á–µ–º –Ω–∏–±—É–¥—å!"
    
    await update.message.reply_text(reply_text, parse_mode=ParseMode.HTML)


async def help_handle(update: Update, context: CallbackContext):
    await register_user_if_not_exists(update, context, update.message.from_user)
    user_id = update.message.from_user.id
    db.set_user_attribute(user_id, "last_interaction", datetime.now())
    await update.message.reply_text(HELP_MESSAGE, parse_mode=ParseMode.HTML)


async def retry_handle(update: Update, context: CallbackContext):
    await register_user_if_not_exists(update, context, update.message.from_user)
    if await is_previous_message_not_answered_yet(update, context): return
    
    user_id = update.message.from_user.id
    db.set_user_attribute(user_id, "last_interaction", datetime.now())

    dialog_messages = db.get_dialog_messages(user_id, dialog_id=None)
    if len(dialog_messages) == 0:
        await update.message.reply_text("–ù–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–π ü§∑‚Äç‚ôÇÔ∏è")
        return

    last_dialog_message = dialog_messages.pop()
    db.set_dialog_messages(user_id, dialog_messages, dialog_id=None)  # last message was removed from the context

    await message_handle(update, context, message=last_dialog_message["user"], use_new_dialog_timeout=False)


async def message_handle(update: Update, context: CallbackContext, message=None, use_new_dialog_timeout=True):
    # check if message is edited
    if update.edited_message is not None:
        await edited_message_handle(update, context)
        return
        
    await register_user_if_not_exists(update, context, update.message.from_user)
    if await is_previous_message_not_answered_yet(update, context): return
    
    
    user_id = update.message.from_user.id
    chat_mode = db.get_user_attribute(user_id, "current_chat_mode")
    await check_user_request(user_id)
    user_request_count = db.get_user_attribute(user_id, "user_request_count")
    
    if user_request_count is None:
        db.add_new_message_count(user_id)
    
    
    if user_request_count <= 0:
         # TODO: –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–ø–∏—Å–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
             await update.message.reply_text("–í—ã –ø—Ä–µ–≤—ã—Å–∏–ª–∏ –ª–∏–º–∏—Ç –∑–∞–ø—Ä–æ—Å–æ–≤. –û—Å—Ç–∞—Ç–æ–∫ –∑–∞–ø—Ä–æ—Å–æ–≤ " + str(user_request_count))
             return
    
    db.minus_message_count(user_id)
    
    async with user_semaphores[user_id]:
        # new dialog timeout
        if use_new_dialog_timeout:
            if (datetime.now() - db.get_user_attribute(user_id, "last_interaction")).seconds > config.new_dialog_timeout and len(db.get_dialog_messages(user_id)) > 0:
                db.start_new_dialog(user_id)
                await update.message.reply_text(f"–ù–∞—á–∞–ª–æ –Ω–æ–≤–æ–≥–æ –¥–∏–∞–ª–æ–≥–∞ –∏–∑-–∑–∞ —Ç–∞–π–º-–∞—É—Ç–∞ (<b>{openai_utils.CHAT_MODES[chat_mode]['name']}</b> mode) ‚úÖ", parse_mode=ParseMode.HTML)
        db.set_user_attribute(user_id, "last_interaction", datetime.now())

        # send typing action
        await update.message.chat.send_action(action="typing")

        try:
            message = message or update.message.text

            current_model = db.get_user_attribute(user_id, "current_model")
            dialog_messages = db.get_dialog_messages(user_id, dialog_id=None)
            parse_mode = {
                "html": ParseMode.HTML,
                "markdown": ParseMode.MARKDOWN
            }[openai_utils.CHAT_MODES[chat_mode]["parse_mode"]]

            chatgpt_instance = openai_utils.ChatGPT(model=current_model)
            if config.enable_message_streaming:
                gen = chatgpt_instance.send_message_stream(message, dialog_messages=dialog_messages, chat_mode=chat_mode)
            else:
                answer, (n_input_tokens, n_output_tokens), n_first_dialog_messages_removed = await chatgpt_instance.send_message(
                    message,
                    dialog_messages=dialog_messages,
                    chat_mode=chat_mode
                )

                async def fake_gen():
                    yield "finished", answer, (n_input_tokens, n_output_tokens), n_first_dialog_messages_removed

                gen = fake_gen()

            # send message to user
            prev_answer = ""
            i = -1
            async for gen_item in gen:
                i += 1

                status = gen_item[0]
                if status == "not_finished":
                    status, answer = gen_item
                elif status == "finished":
                    status, answer, (n_input_tokens, n_output_tokens), n_first_dialog_messages_removed = gen_item
                else:
                    raise ValueError(f"–°—Ç–∞—Ç—É—Å {status} –Ω–µ–∏–∑–≤–µ—Å—Ç–µ–Ω")

                answer = answer[:4096]  # telegram message limit
                if i == 0:  # send first message (then it'll be edited if message streaming is enabled)
                    try:                    
                        sent_message = await update.message.reply_text(answer, parse_mode=parse_mode)
                    except telegram.error.BadRequest as e:
                        if str(e).startswith("–°–æ–æ–±—â–µ–Ω–∏–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –Ω–µ–ø—É—Å—Ç—ã–º"):  # first answer chunk from openai was empty
                            i = -1  # try again to send first message
                            continue
                        else:
                            sent_message = await update.message.reply_text(answer)
                else:  # edit sent message
                    # update only when 100 new symbols are ready
                    if abs(len(answer) - len(prev_answer)) < 100 and status != "finished":
                        continue

                    try:                    
                        await context.bot.edit_message_text(answer, chat_id=sent_message.chat_id, message_id=sent_message.message_id, parse_mode=parse_mode)
                    except telegram.error.BadRequest as e:
                        if str(e).startswith("–°–æ–æ–±—â–µ–Ω–∏–µ –Ω–µ –∏–∑–º–µ–Ω–µ–Ω–æ"):
                            continue
                        else:
                            await context.bot.edit_message_text(answer, chat_id=sent_message.chat_id, message_id=sent_message.message_id)

                    await asyncio.sleep(0.01)  # wait a bit to avoid flooding
                    
                prev_answer = answer

            # update user data
            new_dialog_message = {"user": message, "bot": answer, "date": datetime.now()}
            db.set_dialog_messages(
                user_id,
                db.get_dialog_messages(user_id, dialog_id=None) + [new_dialog_message],
                dialog_id=None
            )

            db.update_n_used_tokens(user_id, current_model, n_input_tokens, n_output_tokens) 
        except Exception as e:
            error_text = f"–ß—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫ –≤–æ –≤—Ä–µ–º—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è. –ü—Ä–∏—á–∏–Ω–∞: {e}"
            logger.error(error_text)
            await update.message.reply_text(error_text)
            return

        # send message if some messages were removed from the context
        if n_first_dialog_messages_removed > 0:
            if n_first_dialog_messages_removed == 1:
                text = "‚úçÔ∏è <i>Note:</i> –í–∞—à —Ç–µ–∫—É—â–∏–π –¥–∏–∞–ª–æ–≥ —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π, –ø–æ—ç—Ç–æ–º—É –≤–∞—à–µ <b>–ø–µ—Ä–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ</b> –±—ã–ª–æ —É–¥–∞–ª–µ–Ω–æ –∏–∑ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞.\n –û—Ç–ø—Ä–∞–≤—å—Ç–µ –∫–æ–º–∞–Ω–¥—É /new, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å –Ω–æ–≤—ã–π –¥–∏–∞–ª–æ–≥"
            else:
                text = f"‚úçÔ∏è <i>–ü—Ä–∏–º–µ—á–∞–Ω–∏–µ.</i> –í–∞—à —Ç–µ–∫—É—â–∏–π –¥–∏–∞–ª–æ–≥ —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π, –ø–æ—ç—Ç–æ–º—É <b>{n_first_dialog_messages_removed} –ø–µ—Ä–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è</b> –±—ã–ª–∏ —É–¥–∞–ª–µ–Ω—ã –∏–∑ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞.\n –û—Ç–ø—Ä–∞–≤—å—Ç–µ –∫–æ–º–∞–Ω–¥—É /new, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å –Ω–æ–≤—ã–π –¥–∏–∞–ª–æ–≥"
            await update.message.reply_text(text, parse_mode=ParseMode.HTML)


async def is_previous_message_not_answered_yet(update: Update, context: CallbackContext):
    await register_user_if_not_exists(update, context, update.message.from_user)

    user_id = update.message.from_user.id
    if user_semaphores[user_id].locked():
        text = "‚è≥ <b>–ü–æ–¥–æ–∂–¥–∏—Ç–µ</b> –æ—Ç–≤–µ—Ç–∞ –Ω–∞ –ø—Ä–µ–¥—ã–¥—É—â–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ"
        await update.message.reply_text(text, reply_to_message_id=update.message.id, parse_mode=ParseMode.HTML)
        return True
    else:
        return False


async def voice_message_handle(update: Update, context: CallbackContext):
    await register_user_if_not_exists(update, context, update.message.from_user)
    if await is_previous_message_not_answered_yet(update, context): return

    user_id = update.message.from_user.id
    db.set_user_attribute(user_id, "last_interaction", datetime.now())

    voice = update.message.voice
    with tempfile.TemporaryDirectory() as tmp_dir:
        tmp_dir = Path(tmp_dir)
        voice_ogg_path = tmp_dir / "voice.ogg"

        # download
        voice_file = await context.bot.get_file(voice.file_id)
        await voice_file.download_to_drive(voice_ogg_path)

        # convert to mp3
        voice_mp3_path = tmp_dir / "voice.mp3"
        pydub.AudioSegment.from_file(voice_ogg_path).export(voice_mp3_path, format="mp3")

        # transcribe
        with open(voice_mp3_path, "rb") as f:
            transcribed_text = await openai_utils.transcribe_audio(f)

    text = f"üé§: <i>{transcribed_text}</i>"
    await update.message.reply_text(text, parse_mode=ParseMode.HTML)

    # update n_transcribed_seconds
    db.set_user_attribute(user_id, "n_transcribed_seconds", voice.duration + db.get_user_attribute(user_id, "n_transcribed_seconds"))

    await message_handle(update, context, message=transcribed_text)


async def new_dialog_handle(update: Update, context: CallbackContext):
    await register_user_if_not_exists(update, context, update.message.from_user)
    if await is_previous_message_not_answered_yet(update, context): return

    user_id = update.message.from_user.id
    db.set_user_attribute(user_id, "last_interaction", datetime.now())

    db.start_new_dialog(user_id)
    await update.message.reply_text("–ù–∞—á–∏—Ç–∞–µ–º –Ω–æ–≤—ã–π –¥–∏–∞–ª–æ–≥ ‚úÖ")

    chat_mode = db.get_user_attribute(user_id, "current_chat_mode")
    await update.message.reply_text(f"{openai_utils.CHAT_MODES[chat_mode]['welcome_message']}", parse_mode=ParseMode.HTML)


async def show_chat_modes_handle(update: Update, context: CallbackContext):
    await register_user_if_not_exists(update, context, update.message.from_user)
    if await is_previous_message_not_answered_yet(update, context): return

    user_id = update.message.from_user.id
    db.set_user_attribute(user_id, "last_interaction", datetime.now())

    keyboard = []
    for chat_mode, chat_mode_dict in openai_utils.CHAT_MODES.items():
        keyboard.append([InlineKeyboardButton(chat_mode_dict["name"], callback_data=f"set_chat_mode|{chat_mode}")])
    reply_markup = InlineKeyboardMarkup(keyboard)

    await update.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ —Ä–µ–∂–∏–º –±–æ—Ç–∞:", reply_markup=reply_markup)


async def set_chat_mode_handle(update: Update, context: CallbackContext):
    await register_user_if_not_exists(update.callback_query, context, update.callback_query.from_user)
    user_id = update.callback_query.from_user.id

    query = update.callback_query
    await query.answer()

    chat_mode = query.data.split("|")[1]

    db.set_user_attribute(user_id, "current_chat_mode", chat_mode)
    db.start_new_dialog(user_id)

    await query.edit_message_text(f"{openai_utils.CHAT_MODES[chat_mode]['welcome_message']}", parse_mode=ParseMode.HTML)


def get_settings_menu(user_id: int):
    current_model = db.get_user_attribute(user_id, "current_model")
    text = config.models["info"][current_model]["description"]

    text += "\n\n"
    score_dict = config.models["info"][current_model]["scores"]
    for score_key, score_value in score_dict.items():
        text += "üü¢" * score_value + "‚ö™Ô∏è" * (5 - score_value) + f" ‚Äì {score_key}\n\n"

    text += "\nSelect <b>model</b>:"

    # buttons to choose models
    buttons = []
    for model_key in config.models["available_text_models"]:
        title = config.models["info"][model_key]["name"]
        if model_key == current_model:
            title = "‚úÖ " + title

        buttons.append(
            InlineKeyboardButton(title, callback_data=f"set_settings|{model_key}")
        )
    reply_markup = InlineKeyboardMarkup([buttons])

    return text, reply_markup


async def settings_handle(update: Update, context: CallbackContext):
    await register_user_if_not_exists(update, context, update.message.from_user)
    if await is_previous_message_not_answered_yet(update, context): return

    user_id = update.message.from_user.id
    db.set_user_attribute(user_id, "last_interaction", datetime.now())

    text, reply_markup = get_settings_menu(user_id)
    await update.message.reply_text(text, reply_markup=reply_markup, parse_mode=ParseMode.HTML)


async def set_settings_handle(update: Update, context: CallbackContext):
    await register_user_if_not_exists(update.callback_query, context, update.callback_query.from_user)
    user_id = update.callback_query.from_user.id

    query = update.callback_query
    await query.answer()

    _, model_key = query.data.split("|")
    db.set_user_attribute(user_id, "current_model", model_key)
    db.start_new_dialog(user_id)

    text, reply_markup = get_settings_menu(user_id)
    try:                    
        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.HTML)
    except telegram.error.BadRequest as e:
        if str(e).startswith("–°–æ–æ–±—â–µ–Ω–∏–µ –Ω–µ –∏–∑–º–µ–Ω–µ–Ω–æ"):
            pass
    

async def show_balance_handle(update: Update, context: CallbackContext):
    await register_user_if_not_exists(update, context, update.message.from_user)

    user_id = update.message.from_user.id
    db.set_user_attribute(user_id, "last_interaction", datetime.now())

    # count total usage statistics
    total_n_spent_dollars = 0
    total_n_used_tokens = 0

    n_used_tokens_dict = db.get_user_attribute(user_id, "n_used_tokens")
    n_transcribed_seconds = db.get_user_attribute(user_id, "n_transcribed_seconds")

    details_text = "üè∑Ô∏è Details:\n"
    for model_key in sorted(n_used_tokens_dict.keys()):
        n_input_tokens, n_output_tokens = n_used_tokens_dict[model_key]["n_input_tokens"], n_used_tokens_dict[model_key]["n_output_tokens"]
        total_n_used_tokens += n_input_tokens + n_output_tokens

        n_input_spent_dollars = config.models["info"][model_key]["price_per_1000_input_tokens"] * (n_input_tokens / 1000)
        n_output_spent_dollars = config.models["info"][model_key]["price_per_1000_output_tokens"] * (n_output_tokens / 1000)
        total_n_spent_dollars += n_input_spent_dollars + n_output_spent_dollars

        details_text += f"- {model_key}: <b>{n_input_spent_dollars + n_output_spent_dollars:.03f}$</b> / <b>{n_input_tokens + n_output_tokens} tokens</b>\n"

    voice_recognition_n_spent_dollars = config.models["info"]["whisper"]["price_per_1_min"] * (n_transcribed_seconds / 60)
    if n_transcribed_seconds != 0:
        details_text += f"- Whisper (voice recognition): <b>{voice_recognition_n_spent_dollars:.03f}$</b> / <b>{n_transcribed_seconds:.01f} seconds</b>\n"
    
    total_n_spent_dollars += voice_recognition_n_spent_dollars    

    text = f"–í—ã –ø–æ—Ç—Ä–∞—Ç–∏–ª–∏ <b>{total_n_spent_dollars:.03f}$</b>\n"
    text += f"–í—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ <b>{total_n_used_tokens}</b> tokens\n\n"
    text += details_text

    await update.message.reply_text(text, parse_mode=ParseMode.HTML)
    
#–ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–µ –Ω–∞—Å—Ç—É–ø–∏–ª–∞ –ª–∏ –¥–∞—Ç–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –∑–∞–ø—Ä–æ—Å–æ–≤
async def check_user_request(user_id: int):
    user_request_count = db.get_user_attribute(user_id, "user_request_count")
    user_request_date = db.get_user_attribute(user_id, "user_request_date")

    if user_request_count is None:
        db.add_new_message_count(user_id, 0)

    if user_request_date is None or not isinstance(user_request_date, datetime):
        user_request_date = datetime.now()
        db.add_new_message_date(user_id, user_request_date)
    else:
        # user_request_date is already a datetime object, no need to convert it
        pass

    if (user_request_date.date() == datetime.now().date()):
        return
            
    

    if user_request_date.date() < datetime.now().date():
        is_premium = check_prem_pay(user_id)
        if is_premium:
            db.add_new_message_count(user_id, 100)
        else:
            db.add_new_message_count(user_id, 3)

        db.add_new_message_date(user_id)

        
        

async def check_prem_pay(_user_id: int):
    user_id = _user_id
    db.set_user_attribute(user_id, "last_interaction", datetime.now())
    
    
    prem_datetime = db.get_user_attribute(user_id, "prem_datetime")
    if prem_datetime is None:
        db.add_new_prem_date(user_id)
    
    prem_mounts = db.get_user_attribute(user_id, "prem_mounts")
    if prem_mounts is None:
        db.add_new_prem_days(user_id)
    
    prem_datetime = db.get_user_attribute(user_id, "prem_datetime")
    print(prem_datetime)
    label = str(user_id)
    pay_list = checkpay.ympaycheck(label)
    if len(pay_list) > 0:
        for pay_date in pay_list:
            if pay_date > prem_datetime:
                db.add_new_prem_date(user_id, pay_date)
                db.add_new_prem_days(user_id, 30)
                return True
            else:
                return False
            
        
    
async def check_prem(_user_id: int):
    
    user_id = _user_id
    
    prem_datetime = db.get_user_attribute(user_id, "prem_datetime")
    
    if prem_datetime is None:
        db.add_new_prem_date(user_id)
    
    prem_mounts = db.get_user_attribute(user_id, "prem_mounts")
    if prem_mounts is None:
        db.add_new_prem_days(user_id)
    
    # –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ —Å—Ç—Ä–æ–∫–∏ –¥–∞—Ç—ã –∏ –≤—Ä–µ–º–µ–Ω–∏ –≤ –æ–±—ä–µ–∫—Ç datetime
    if isinstance(prem_datetime, str):
        prem_datetime = datetime.strptime(prem_datetime, "%Y-%m-%d %H:%M:%S")

    # –≤—ã—á–∏—Å–ª–µ–Ω–∏–µ –¥–∞—Ç—ã –æ–∫–æ–Ω—á–∞–Ω–∏—è –ø—Ä–µ–º–∏—É–º-–ø–æ–¥–ø–∏—Å–∫–∏
    prem_end_date = prem_datetime + timedelta(days=prem_mounts)
    # –≤—ã–≤–æ–¥ –¥–∞—Ç—ã –æ–∫–æ–Ω—á–∞–Ω–∏—è –ø—Ä–µ–º–∏—É–º-–ø–æ–¥–ø–∏—Å–∫–∏
    #print(prem_end_date.strftime("%Y-%m-%d %H:%M:%S"))
    if (prem_end_date > datetime.now()):
        return True, prem_end_date
    else:
        return False, datetime.now()

async def show_premium_handle(update: Update, context: CallbackContext):
    await register_user_if_not_exists(update, context, update.message.from_user)

    user_id = update.message.from_user.id 
    db.set_user_attribute(user_id, "last_interaction", datetime.now())
    
    check_pr = await check_prem_pay(user_id)
    prem_status, prem_end = await check_prem(user_id)
    
    
    if (prem_status):
        keyboard = []
        keyboard.append([InlineKeyboardButton(text="–ö–∞—Ä—Ç–æ–π 250—Ä –Ω–∞ 1 –º–µ—Å—è—Ü", url=ymquickpay.ympay1m(user_id))])
        reply_markup = InlineKeyboardMarkup(keyboard)
        prem_end_date_str = prem_end.date().strftime("%Y-%m-%d")
        await check_user_request(user_id)
        user_request_count = db.get_user_attribute(user_id, "user_request_count")
        if check_pr:
            db.add_new_message_count(user_id, 100)
            db.add_new_message_date(user_id)
            await update.message.reply_html("–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –ü–ª–∞—Ç–µ–∂ —É—Å–ø–µ—à–Ω–æ –ø—Ä–æ–≤–µ–¥—ë–Ω. –£ –≤–∞—Å –∞–∫—Ç–∏–≤–Ω–∞—è –ø–æ–¥–ø–∏—Å–∫–∞ –¥–æ <b>{date}</b>\n–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ—Å—Ç–∞–≤—à–∏—Ö—Å—è —Å–æ–æ–±—â–µ–Ω–∏–π –≤ —ç—Ç–∏ —Å—É—Ç–∫–∏ <b>{request}</b>".format(date=prem_end_date_str, request=user_request_count), reply_markup=reply_markup)
            
        else:
            await update.message.reply_html("–£ –≤–∞—Å –∞–∫—Ç–∏–≤–Ω–∞—è –ø–æ–¥–ø–∏—Å–∫–∞ –¥–æ <b>{date}</b>\n–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ—Å—Ç–∞–≤—à–∏—Ö—Å—è —Å–æ–æ–±—â–µ–Ω–∏–π –≤ —ç—Ç–∏ —Å—É—Ç–∫–∏ <b>{request}</b>. –ù–∞–∂–º–∏—Ç–µ /premuim –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –Ω–æ–≤—ã—Ö –ø–ª–∞—Ç–µ–∂–µ–π".format(date=prem_end_date_str, request=user_request_count), reply_markup=reply_markup)
    else:
        keyboard = []
        keyboard.append([InlineKeyboardButton(text="–ö–∞—Ä—Ç–æ–π 250—Ä –Ω–∞ 1 –º–µ—Å—è—Ü", url=ymquickpay.ympay1m(user_id))])
        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text("–ù–∞–∂–º–∏—Ç–µ /premuim –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –Ω–æ–≤—ã—Ö –ø–ª–∞—Ç–µ–∂–µ–π –∏–ª–∏ –í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–¥–ø–∏—Å–∫—É –∏ —Å–ø–æ—Å–æ–± –æ–ø–ª–∞—Ç—ã:", reply_markup=reply_markup)


async def edited_message_handle(update: Update, context: CallbackContext):
    text = "ü•≤ –ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, <b>—Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ</b> —Å–æ–æ–±—â–µ–Ω–∏–π –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è"
    await update.edited_message.reply_text(text, parse_mode=ParseMode.HTML)


async def error_handle(update: Update, context: CallbackContext) -> None:
    logger.error(msg="–ò—Å–∫–ª—é—á–µ–Ω–∏–µ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è:", exc_info=context.error)

    try:
        # collect error message
        tb_list = traceback.format_exception(None, context.error, context.error.__traceback__)
        tb_string = "".join(tb_list)
        update_str = update.to_dict() if isinstance(update, Update) else str(update)
        message = (
            f"–ü—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –≤–æ–∑–Ω–∏–∫–ª–æ –∏—Å–∫–ª—é—á–µ–Ω–∏–µ\n"
            f"<pre>update = {html.escape(json.dumps(update_str, indent=2, ensure_ascii=False))}"
            "</pre>\n\n"
            f"<pre>{html.escape(tb_string)}</pre>"
        )

        # split text into multiple messages due to 4096 character limit
        for message_chunk in split_text_into_chunks(message, 4096):
            try:
                await context.bot.send_message(update.effective_chat.id, message_chunk, parse_mode=ParseMode.HTML)
            except telegram.error.BadRequest:
                # answer has invalid characters, so we send it without parse_mode
                await context.bot.send_message(update.effective_chat.id, message_chunk)
    except:
        await context.bot.send_message(update.effective_chat.id, "–ö–∞–∫–∞—è-—Ç–æ –æ—à–∏–±–∫–∞ –≤ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–µ –æ—à–∏–±–æ–∫")

async def post_init(application: Application):
    await application.bot.set_my_commands([
        BotCommand("/new", "–ù–∞—á–∞—Ç—å –Ω–æ–≤—ã–π –¥–∏–∞–ª–æ–≥"),
        BotCommand("/mode", "–í—ã–±—Ä–∞—Ç—å —Ä–µ–∂–∏–º —Ä–∞–±–æ—Ç—ã –±–æ—Ç–∞"),
        BotCommand("/retry", "–†–µ–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–µ–¥–∏–¥—É—â–∏–π –∑–∞–ø—Ä–æ—Å"),
        BotCommand("/premium", "–ü–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ –ø—Ä–µ–º–∏—É–º"),
        BotCommand("/balance", "–ü–æ–∫–∞–∑–∞—Ç—å –±–∞–ª–∞–Ω—Å"),
        BotCommand("/settings", "–ü–æ–∫–∞–∑–∞—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏"),
        BotCommand("/help", "–ü–æ–º–æ—â—å"),
    ])

def run_bot() -> None:
    application = (
        ApplicationBuilder()
        .token(config.telegram_token)
        .concurrent_updates(True)
        .rate_limiter(AIORateLimiter(max_retries=5))
        .post_init(post_init)
        .build()
    )

    # add handlers
    user_filter = filters.ALL
    if len(config.allowed_telegram_usernames) > 0:
        usernames = [x for x in config.allowed_telegram_usernames if isinstance(x, str)]
        user_ids = [x for x in config.allowed_telegram_usernames if isinstance(x, int)]
        user_filter = filters.User(username=usernames) | filters.User(user_id=user_ids)

    application.add_handler(CommandHandler("start", start_handle, filters=user_filter))
    application.add_handler(CommandHandler("help", help_handle, filters=user_filter))

    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND & user_filter, message_handle))
    application.add_handler(CommandHandler("retry", retry_handle, filters=user_filter))
    application.add_handler(CommandHandler("new", new_dialog_handle, filters=user_filter))

    application.add_handler(MessageHandler(filters.VOICE & user_filter, voice_message_handle))
    
    application.add_handler(CommandHandler("mode", show_chat_modes_handle, filters=user_filter))
    application.add_handler(CallbackQueryHandler(set_chat_mode_handle, pattern="^set_chat_mode"))

    application.add_handler(CommandHandler("settings", settings_handle, filters=user_filter))
    application.add_handler(CallbackQueryHandler(set_settings_handle, pattern="^set_settings"))

    application.add_handler(CommandHandler("balance", show_balance_handle, filters=user_filter))
    
    application.add_handler(CommandHandler("premium", show_premium_handle, filters=user_filter))
    application.add_error_handler(error_handle)
    
    # start the bot
    application.run_polling()


if __name__ == "__main__":
    run_bot()